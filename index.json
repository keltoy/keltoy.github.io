[{"categories":null,"content":" import torch # 行向量 x = torch.arange(12) x tensor([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) # 张量形状 x.shape torch.Size([12]) # 元素总数 x.numel() 12 # 改变顺序 X = x.reshape(3, 4) X tensor([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) # 全零 torch.zeros((2, 3, 4)) tensor([[[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]], [[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]]]) # 全1 torch.ones((2, 3, 4)) tensor([[[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.]], [[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.]]]) # 随机张量 torch.randn(3, 4) tensor([[ 1.2938, 0.0115, -1.1682, -0.8837], [ 0.5345, -0.3015, -1.2261, 0.0236], [ 1.4058, -1.2990, 0.5318, -0.9359]]) # 创建张量 torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]]) tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]]) # 四则运算 x = torch.tensor([1.0, 2, 4, 8]) y = torch.tensor([2, 2, 2, 2]) x + y, x - y, x * y, x / y, x ** y # **运算符是求幂运算 (tensor([ 3., 4., 6., 10.]), tensor([-1., 0., 2., 6.]), tensor([ 2., 4., 8., 16.]), tensor([0.5000, 1.0000, 2.0000, 4.0000]), tensor([ 1., 4., 16., 64.])) torch.exp(x) tensor([2.7183e+00, 7.3891e+00, 5.4598e+01, 2.9810e+03]) # 连接两个张量 X = torch.arange(12, dtype=torch.float32).reshape((3,4)) Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]]) torch.cat((X, Y), dim=0), torch.cat((X, Y), dim=1) (tensor([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [ 2., 1., 4., 3.], [ 1., 2., 3., 4.], [ 4., 3., 2., 1.]]), tensor([[ 0., 1., 2., 3., 2., 1., 4., 3.], [ 4., 5., 6., 7., 1., 2., 3., 4.], [ 8., 9., 10., 11., 4., 3., 2., 1.]])) # 张量判断 X == Y tensor([[False, True, False, True], [False, False, False, False], [False, False, False, False]]) X.sum() tensor(66.) a = torch.arange(3).reshape((3, 1)) b = torch.arange(2).reshape((1, 2)) a, b (tensor([[0], [1], [2]]), tensor([[0, 1]])) # 矩阵广播 a + b tensor([[0, 1], [1, 2], [2, 3]]) X,X[-1], X[1:3] (tensor([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.]]), tensor([ 8., 9., 10., 11.]), tensor([[ 4., 5., 6., 7.], [ 8., 9., 10., 11.]])) X[1, 2] = 9 X tensor([[ 0., 1., 2., 3.], [ 4., 5., 9., 7.], [ 8., 9., 10., 11.]]) X[0:2, :] = 12 X tensor([[12., 12., 12., 12.], [12., 12., 12., 12.], [ 8., 9., 10., 11.]]) # 使用id before = id(Y) Y = Y + X id(Y) == before False # 使用 Z[:] 和 X+= 来节省内存 Z = torch.zeros_like(Y) print('id(Z):', id(Z)) Z[:] = X + Y print('id(Z):', id(Z)) id(Z): 5145260816 id(Z): 5145260816 before = id(X) X += Y id(X) == before True # numpy 的相互转换 A = X.numpy() B = torch.tensor(A) type(A), type(B) (numpy.ndarray, torch.Tensor) # 标量 a = torch.tensor([3.5]) a, a.item(), float(a), int(a) (tensor([3.5000]), 3.5, 3.5, 3) ","date":"2023-04-27","objectID":"/deep-learning-prefix/:0:0","tags":["ml"],"title":"Torch 预热","uri":"/deep-learning-prefix/"},{"categories":null,"content":"介绍 AggHandlerCodeGenerator 的代码在 flink planner 下，用来生成聚合函数的代码,是scala 代码 ","date":"2022-09-26","objectID":"/flink-agghandlercodegenerator/:0:0","tags":["flink"],"title":"Flink AggHandlerCodeGenerator","uri":"/flink-agghandlercodegenerator/"},{"categories":null,"content":"类定义 classDiagram class AggsHandlerCodeGenerator{ +CodeGeneratorContext ctx +RelBuilder relBuilder +Seq~LogicalType~ inputFieldTypes +Boolean copyInputField +RowType inputType +Seq~RexLiteral~ constants -Seq~GeneratedExpression~ constantExprs -String namespaceClassName -Seq~PlannerWindowProperty~ windowProperties -Boolean hasNamespace -RowType accTypeInfo -Int aggBufferSize -Array~DataType~ mergedAccExternalTypes -Int mergedAccOffset -Boolean mergedAccOnHeap -Array~Int~ ignoreAggValues -Boolean isAccumulateNeeded -Boolean isRetractNeeded -Boolean isMergeNeeded +RowType valueType: -Array~AggCodeGen~ aggBufferCodeGens -Array~AggCodeGen~ aggActionCodeGens +AggsHandlerCodeGenerator withConstants(Seq~RexLiteral~ literals ): } package org.apache.flink.table.planner.codegen.agg class AggsHandlerCodeGenerator( ctx: CodeGeneratorContext, // 上下文 relBuilder: RelBuilder, // 用来生成关系表达式 inputFieldTypes: Seq[LogicalType], copyInputField: Boolean // 需要缓存时将此字段设置为true) { private val inputType = RowType.of(inputFieldTypes: _*) /** 常量表达式 */ private var constants: Seq[RexLiteral] = Seq() private var constantExprs: Seq[GeneratedExpression] = Seq() /** 窗口相关参数，窗口聚合才会用到 */ private var namespaceClassName: String = _ private var windowProperties: Seq[PlannerWindowProperty] = Seq() private var hasNamespace: Boolean = false /** 聚合信息 */ private var accTypeInfo: RowType = _ private var aggBufferSize: Int = _ private var mergedAccExternalTypes: Array[DataType] = _ private var mergedAccOffset: Int = 0 private var mergedAccOnHeap: Boolean = false private var ignoreAggValues: Array[Int] = Array() private var isAccumulateNeeded = false private var isRetractNeeded = false private var isMergeNeeded = false var valueType: RowType = _ /** * 生成 [[AggsHandleFunction]] 或者 [[NamespaceAggsHandleFunction]] 会创建 [[aggBufferCodeGens]] and [[aggActionCodeGens]] 两者包含相同的AggCodeGens，aggBufferCodeGens 以列表的扁平形式， aggActionCodeGens是树形结构 在没有distinct 的的情况下，两者相同 */ /** aggBufferCodeGens 用于生成相关累加器(Accumulator)的 方法 */ private var aggBufferCodeGens: Array[AggCodeGen] = _ /** aggActionCodeGens 树形结构，聚合distinct数据的时候，会将相同需要distinct的字段组成树结构 */ private var aggActionCodeGens: Array[AggCodeGen] = _ object aggshandlercodegenerator { /** static terms **/ val acc_term = \"acc\" val merged_acc_term = \"otheracc\" val accumulate_input_term = \"accinput\" val retract_input_term = \"retractinput\" val distinct_key_term = \"distinctkey\" val namespace_term = \"namespace\" val store_term = \"store\" val collector: string = classname[collector[_]] val collector_term = \"out\" val member_collector_term = \"convertcollector\" val convert_collector_type_term = \"convertcollector\" val key_term = \"groupkey\" val input_not_null = false } 如果一个SQL的结构如下 count(*),count(distincta),count(distincta)filterd\u003e5,sum(a),sum(distincta)+----------+-----------+-----------+---------+---------+----------------+ |count(*)|count(a') | count(a')|sum(a)|sum(a') | distinct(a) a'|+----------+-----------+-----------+---------+---------+----------------+ 那么 aggBufferCodeGens 会这样保存 ┌────────┬──────────┬──────────┬───────┬────────┬────────────┐ │count(*)│ count(a')│ count(a')│ sum(a)│ sum(a')│ distinct(a)│ └────────┴──────────┴──────────┴───────┴────────┴────────────┘ aggActionCodeGens 会这样保存 ┌─────────────────────────────┬───────┬────────────────────────────────┐ │ count(*) │ sum(a)│ distinct(a) a' │ │ │ │ ├─count(a') │ │ │ │ ├─count(a') (filter d \u003e 5) │ │ │ │ └─sum(a') │ └─────────────────────────────┴───────┴────────────────────────────────┘ ","date":"2022-09-26","objectID":"/flink-agghandlercodegenerator/:1:0","tags":["flink"],"title":"Flink AggHandlerCodeGenerator","uri":"/flink-agghandlercodegenerator/"},{"categories":null,"content":"CodeGeneratorContext package org.apache.flink.table.planner.codegen /** 生成代码的上下文，维护代码段的状态 */ class CodeGeneratorContext(val tableConfig: TableConfig) { // 保存用于传递生成类的对象列表 val references: mutable.ArrayBuffer[AnyRef] = new mutable.ArrayBuffer[AnyRef]() // 插入有序，只会被添加一次， 成员状态 private val reusableMemberStatements: mutable.LinkedHashSet[String] = mutable.LinkedHashSet[String]() // 插入有序，只会被添加一次， 构造状态 private val reusableInitStatements: mutable.LinkedHashSet[String] = mutable.LinkedHashSet[String]() // 插入有序，只会被添加一次， RichFunction 中open方法的状态 private val reusableOpenStatements: mutable.LinkedHashSet[String] = mutable.LinkedHashSet[String]() // 插入有序，只会被添加一次， RichFunction 中close方法的状态 private val reusableCloseStatements: mutable.LinkedHashSet[String] = mutable.LinkedHashSet[String]() // 插入有序，只会被添加一次， 清理 dataview 的状态 private val reusableCleanupStatements = mutable.LinkedHashSet[String]() // 单个记录的状态， 插入有序，因为本地变量需要被分割，所以本地变量无法访问，只能更新成员变量 private val reusablePerRecordStatements: mutable.LinkedHashSet[String] = mutable.LinkedHashSet[String]() // (inputTerm, index) -\u003e expr // 只会被添加一次， 初始化拆箱表达式Map val reusableInputUnboxingExprs: mutable.Map[(String, Int), GeneratedExpression] = mutable.Map[(String, Int), GeneratedExpression]() // 插入有序，只会被添加一次，构造函数的状态 private val reusableConstructorStatements: mutable.LinkedHashSet[(String, String)] = mutable.LinkedHashSet[(String, String)]() // 插入有序，只会被添加一次，类声明状态 private val reusableInnerClassDefinitionStatements: mutable.Map[String, String] = mutable.Map[String, String]() // string_constant -\u003e reused_term // 常量 private val reusableStringConstants: mutable.Map[String, String] = mutable.Map[String, String]() // LogicalType -\u003e reused_term // 类型序列化 private val reusableTypeSerializers: mutable.Map[LogicalType, String] = mutable.Map[LogicalType, String]() /** * Flag map that indicates whether the generated code for method is split into several methods. */ private val isCodeSplitMap = mutable.Map[String, Boolean]() // method_name -\u003e local_variable_statements private val reusableLocalVariableStatements = mutable.Map[String, mutable.LinkedHashSet[String]]( (currentMethodNameForLocalVariables, mutable.LinkedHashSet[String]())) ","date":"2022-09-26","objectID":"/flink-agghandlercodegenerator/:1:1","tags":["flink"],"title":"Flink AggHandlerCodeGenerator","uri":"/flink-agghandlercodegenerator/"},{"categories":null,"content":"Toxi Alisa ","date":"2022-09-02","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"}]